class Key extends Phaser.Group
	# internal class
	class KeyFactory
		@ENTER_CODE = -8
		@BACKSPACE_CODE = -13
		@ENTER = (game)->
			new Key(game, @ENTER_CODE, '√')
		@BACKSPACE = (game)->
			new Key(game, @BACKSPACE_CODE, '←')

	# public class attributes
	<% CHARACTER_RES = 'characters_all'%>
	@new            = KeyFactory
	@CHARACTER_RES  = '<%= CHARACTER_RES %>'
	@States         = {
		NORMAL: 0x0
		OVER:   0x1
		DOWN:   0x2
	}
	@DEFAULT_SIZE = 50

	# public class methods
	@preload: (game)->
		game.load.spritesheet(CHARACTER_RES,'<%= image_path("#{CHARACTER_RES}.png") %>', 160, 160, 59)

	# internal class attributes
	Colors          = {         
		NORMAL: '#FFFFFF'
		OVER:   '#DDDDDD'
		DOWN:   '#EEEEEE'
	}
	CHARACTER_RES   = @CHARACTER_RES
	DEFAULT_SIZE    = @DEFAULT_SIZE
	States          = @States
	BACKGROUD_COLOR	= '#FFFFFF'

	# public instance methods
	constructor: (game, keycode, letter, size)->
		super(game, null, "SoftKeyboard-Key")
		@keysize = size || DEFAULT_SIZE
		@letter = keycode
		@keycode = keycode
		@state = States.NORMAL

		# init methods
		init_background = =>
			bmd = game.add.bitmapData(@keysize, @keysize);
			bmd.ctx.beginPath()
			bmd.ctx.rect(0, 0, @keysize, @keysize)
			@background = new Phaser.Sprite(game, 0, 0, bmd)
			@background.fillColor = (color)->
				@key.ctx.fillStyle = color
				@key.ctx.fill()
			@background.fillColor(BACKGROUD_COLOR)
			@add(@background)

		init_with_character = =>
			@character =new Phaser.Sprite(game, 0, 0, CHARACTER_RES, keycode)
			@character.height = @character.width = @keysize
			@add(@character)

		init_with_letter = =>
			style = { font: "32px Arial", fill: "#233333" }
			text = new Phaser.Text(game, 14, 5, letter, style)
			@letter = letter
			@add(text)
		## ====

		init_background()
		if letter
			init_with_letter()
		else
			init_with_character()
		@enable_input()

	enable_input: =>
		@background.inputEnabled = true;
		e = @background.events
		e.onInputOver.add(@overHandler, this)
		e.onInputOut.add(@outHandler, this)
		e.onInputDown.add(@downHandler, this)
		e.onInputUp.add(@upHandler, this)
		@keyOver = @keyOut = @keyDown = @keyUp = null

	overHandler: =>
		@background.fillColor(Colors.OVER)
		@state = States.OVER
		if @keyOver
			@keyOver(this)

	outHandler: =>
		@background.fillColor(Colors.NORMAL)
		@state = States.NORMAL
		if @keyOut
			@keyOut(this)

	downHandler: =>
		if @state == States.OVER
			@background.fillColor(Colors.DOWN)
			console.log(@keycode)
		if @keyDown
			@keyDown(this)

	upHandler: ->
		if @state == States.OVER
			@background.fillColor(Colors.OVER)

	toString: ()->
		{keycode: @keycode, letter: @letter}.toString()

class InputBar extends Phaser.Group
	BACKGROUD_COLOR = '#DDDDEE'
	constructor: (game, keyboard)->
		super(game, null, "SoftKeyboard-InputBar")
		@game = game
		@ch_queue = []
		@keysize = keyboard.keysize
		@row_size = keyboard.row_size
		@_character_textures = {}

		init_background = =>
			bmd = game.add.bitmapData(@row_size*@keysize, @keysize)
			bmd.ctx.beginPath()
			bmd.ctx.rect(0, 0, @row_size*@keysize, @keysize)
			bmd.ctx.fillStyle = BACKGROUD_COLOR
			bmd.ctx.fill()
			@add(new Phaser.Sprite(game, 0, 0, bmd))

		init_charaters = =>
			c = game.cache
			img = game.cache.getImage(Key.CHARACTER_RES);
			@_characters_bitmapdata = bmd = game.make.bitmapData(img.width, img.height)
			bmd.draw(img, 0, 0, img.width, img.height)
			bmd.update()
			bmd.replaceRGB(0,0,0,255, 70,30,30,255)


		init_background()
		init_charaters()

	addCh: (key)->
		@ch_queue.push(key)
		@update_text()

	backspace: ->
		return if @ch_queue.length==0
		@ch_queue.pop()
		@update_text()

	update_text: ->
		tmp = @ch_queue
		@removeAll()
		@ch_queue = tmp
		visible_chs = if @ch_queue.length>@row_size then @ch_queue[-@row_size..-1] else @ch_queue
		pre_character = null
		for ch, i in visible_chs
			keycode = ch.keycode
			if !(texture = @_character_textures[keycode])
				tmp = new Phaser.Sprite(@game, 0, 0, @_characters_bitmapdata)
				fd = @game.cache.getFrameData(Key.CHARACTER_RES)
				tmp.animations.loadFrameData(fd, keycode)
				tmp.destroy()

				bmd = @game.make.bitmapData(@keysize, @keysize)
				bmd.draw(tmp, 0, 0, @keysize, @keysize)
				bmd.update()
				@_character_textures[keycode] = texture = bmd

			character = new Phaser.Sprite(@game, 0, 0, texture)
			character.x = i*@keysize
			@add(character)

	removeAll: ->
		if @children.length > 1
			@removeBetween(1, @children.length-1, true)
		@ch_queue = []

class SoftKeyboard extends Phaser.Group
	KEY_NUM = 59

	@preload: (game)->
		Key.preload(game)

	constructor: (game)->
		super(game, null, "SoftKeyboard")
		@keys = {}
		@row_size = 13
		@keysize = Key.DEFAULT_SIZE
		@onPosted = new Phaser.Signal()
		@key_pad = new Phaser.Group(game)
		@key_preview = new Phaser.Group(game)
		KEY_PREVIEW_SIZE = 160
		for i in [0...KEY_NUM]
			keycode = i
			key = new Key(game, keycode)
			@key_pad.add(key)
			key.x = (i%@row_size)*(key.keysize+0)
			key.y = Math.floor(i/@row_size)*(key.keysize+0)
			@keys[keycode] = key
			keys = @keys
			# key.keyOver()
			key.keyOver = (key) =>
				bigKey = new Key(game, key.keycode, undefined, KEY_PREVIEW_SIZE)
				@key_preview.removeAll(true)
				@key_preview.add(bigKey)
				# @add(bigKey)
				for k,v of keys
					if parseInt(k) != key.keycode
						v.outHandler()
			key.keyOut = (key) =>
				for k,v of keys
					if v.state == Key.States.OVER
						return
				@key_preview.removeAll(true)

			key.keyDown = (key) =>
				@inputbar.addCh(key)

		backspace = Key.new.BACKSPACE(game)
		backspace.x = ((KEY_NUM)%@row_size)*(key.keysize+0)
		backspace.y = Math.floor((KEY_NUM)/@row_size)*(key.keysize+0)
		backspace.keyDown = (key) =>
			@inputbar.backspace()
		enter = Key.new.ENTER(game)
		enter.x = ((KEY_NUM+1)%@row_size)*(key.keysize+0)
		enter.y = Math.floor((KEY_NUM+1)/@row_size)*(key.keysize+0)
		enter.keyDown = (key) =>
			@handlePost()
		@key_pad.add(enter)
		@key_pad.add(backspace)


		@inputbar = new InputBar(game, this)
		@add(@inputbar)
		@key_pad.y = @inputbar.height
		@add(@key_pad)

		@key_preview.x = -KEY_PREVIEW_SIZE-5
		@add(@key_preview)
		@y = game.camera.view.height - (@height + 24);
		@alpha = 0.95

	hide: ->
		@visible = false

	handleKey: (key)->
		switch key.keycode
			when Key.new.BACKSPACE_CODE
				@inputbar.backspace()
			when Key.new.ENTER_CODE
				@handlePost()
			else
				@inputbar.addCh(key)
	handlePost: ->
		code_ar = []
		for key in @inputbar.ch_queue
			code_ar.push(key.keycode)
		console.log(code_ar)
		alert(code_ar)
		@inputbar.removeAll()
		@onPosted.dispatch(this)
